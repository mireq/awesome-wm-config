#!/usr/bin/env python3
from subprocess import check_output
import argparse
import re


SCREEN_RE = re.compile(r'^Screen (?P<screen>\d+):.*$')
OUTPUT_RE = re.compile(r'^(?P<name>[a-zA-Z0-9\-]+) (?P<connected>connected|disconnected) ?(?P<primary>primary)? ?(?P<position>\d+x\d+\+\d+\+\d+)? ?(?P<orientation>normal|left|inverted|right)?.*$')


def parse_output(output):
	property_name = None
	property_value = ''
	property_info = []
	properties = {}
	modes = []
	output_is_enabled = False

	for line in output:
		if line.startswith('\t\t'):
			property_info.append(line.strip())
		elif line.startswith('\t'):
			try:
				if property_name is not None:
					properties[property_name] = {
						'value': property_value,
						'info': property_info,
					}
					property_value = ''
					property_info = []
				property_name, property_value = line.split(':', 1)
				property_name = property_name.strip()
				property_value = property_value.strip()
			except ValueError:
				property_name = line.strip()
		elif line.startswith('   '): # mode
			line = line.replace(' +', '+').split()
			mode = line[0]
			for framerate in line[1:]:
				is_default = framerate.endswith('+')
				if is_default:
					framerate = framerate[:-1]
				is_enabled = framerate.endswith('*')
				if is_enabled:
					framerate = framerate[:-1]
				output_is_enabled = output_is_enabled or is_enabled
				modes.append({
					'mode': mode,
					'is_default': is_default,
					'is_enabled': is_enabled,
					'framerate': framerate,
				})
	
	if property_name is not None:
		properties[property_name] = {
			'value': property_value,
			'info': property_info,
		}
		property_value = ''
		property_info = []

	return {
		'properties': properties,
		'modes': modes,
		'is_enabled': output_is_enabled,
	}

def parse_outputs(output):
	outputs = {}
	current_output = None
	current_output_lines = []

	for line in output:
		match = OUTPUT_RE.match(line)
		if match is not None:
			if current_output is not None:
				output = parse_output(current_output_lines)
				output['connected'] = current_output['connected'] == 'connected'
				output['primary'] = bool(current_output['primary'])
				output['orientation'] = current_output['orientation'] or 'normal'
				outputs[current_output['name']] = output
			current_output = match.groupdict()
			current_output_lines = []
		else:
			current_output_lines.append(line)
	if current_output is not None:
		output = parse_output(current_output_lines)
		output['connected'] = current_output['connected'] == 'connected'
		output['primary'] = bool(current_output['primary'])
		output['orientation'] = current_output['orientation'] or 'normal'
		outputs[current_output['name']] = output
	return outputs


def parse_screens(output):
	screens = {}
	current_screen = None
	current_screen_lines = []
	for line in output:
		match = SCREEN_RE.match(line)
		if match is not None:
			if current_screen is not None:
				outputs = parse_outputs(current_screen_lines)
				screens[current_screen] = outputs
			current_screen = match.groupdict()['screen']
			current_screen_lines = []
		else:
			current_screen_lines.append(line)
	if current_screen is not None:
		outputs = parse_outputs(current_screen_lines)
		screens[current_screen] = outputs
	return screens


def parse_xrandr():
	xrandr_output = check_output(["xrandr", '--properties']).decode("utf-8").splitlines()
	return parse_screens(xrandr_output)


def activate_next_layout(screen_info):
	screen_info = [(output, info) for output, info in screen_info.items() if info['connected']]
	for enabled_output_index, info in enumerate(screen_info):
		if info[1]['is_enabled']:
			break
	next_enabled_output_index = (enabled_output_index + 1) % len(screen_info)


def main():
	parser = argparse.ArgumentParser(description='Display switcher')
	parser.add_argument('--screen', default='0')
	args = parser.parse_args()

	screen_info = parse_xrandr()[args.screen]
	activate_next_layout(screen_info)


if __name__ == "__main__":
	main()
